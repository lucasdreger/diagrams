name: Convert Draw.io Files with Simple ID Assignment

on:
  push:
    paths:
      - '**/*.drawio'
      - 'drawio_files/**'
  workflow_dispatch: # Enable manual triggering
    inputs:
      convert_all:
        description: 'Convert all diagrams (not just changed ones)'
        required: false
        default: 'false'
        type: choice
        options:
          - 'true'
          - 'false'

# Add concurrency control to prevent queued workflows
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}-${{ github.sha }}
  cancel-in-progress: false

# Add permissions needed for the workflow
permissions:
  contents: write

jobs:
  convert:
    runs-on: ubuntu-latest

    steps:
      # Step 1: Check out the repository
      - name: Check out the repository
        uses: actions/checkout@v3
        with:
          fetch-depth: 0 # Fetch all history to detect changes
          
      # Step 2: Install dependencies
      - name: Install Draw.io and dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y wget unzip xvfb libasound2t64 libgbm1 libnspr4 libnss3 libxss1
          wget https://github.com/jgraph/drawio-desktop/releases/download/v26.2.2/drawio-amd64-26.2.2.deb
          sudo apt-get -f install -y
          sudo dpkg -i drawio-amd64-26.2.2.deb || sudo apt-get -f install -y
          
      # Step 3: Create required directories
      - name: Create required directories
        run: |
          mkdir -p drawio_files svg_files html_files
          
          # Initialize CSV changelog with headers if it doesn't exist
          if [ ! -f "html_files/CHANGELOG.csv" ]; then
            echo "Date,Time,User,Diagram,Action,File,Commit Message,Version,Commit Hash,ID" > html_files/CHANGELOG.csv
          fi
      
      # Step 4: Find modified Draw.io files
      - name: Find modified Draw.io files
        id: changes
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" && "${{ github.event.inputs.convert_all }}" == "true" ]]; then
            echo "Using all Draw.io files"
            find drawio_files -name "*.drawio" > /tmp/changed_files.txt
            echo "all_files=true" >> $GITHUB_OUTPUT
            echo "has_changes=true" >> $GITHUB_OUTPUT
          else
            echo "Finding changed Draw.io files"
            git diff --name-only ${{ github.event.before }} ${{ github.event.after }} | grep "\.drawio$" > /tmp/changed_files.txt || true
            
            # Check if there are changes
            if [ -s /tmp/changed_files.txt ]; then
              echo "Changed Draw.io files found:"
              cat /tmp/changed_files.txt
              echo "all_files=false" >> $GITHUB_OUTPUT
              echo "has_changes=true" >> $GITHUB_OUTPUT
            else
              echo "No changed Draw.io files"
              echo "all_files=false" >> $GITHUB_OUTPUT
              echo "has_changes=false" >> $GITHUB_OUTPUT
            fi
          fi
      
      # Step 5: Add simple IDs and convert Draw.io files
      - name: Add IDs to Draw.io files and convert to SVG/HTML
        if: steps.changes.outputs.has_changes == 'true'
        run: |
          # Create our simple ID assignment script
          cat > /tmp/ultra_simple_id.sh << 'EOL'
          #!/bin/bash
          # Assign a simple incremental ID to diagrams
          
          # Configuration
          ID_FILE="drawio_files/.id_counter"
          
          # Ensure we have an initial ID counter
          if [ ! -f "$ID_FILE" ]; then
            echo "1" > "$ID_FILE"
            echo "Created new ID counter file"
          fi
          
          # Get the current ID and increment it
          CURRENT_ID=$(cat "$ID_FILE" 2>/dev/null || echo "1")
          echo "Current ID counter is: $CURRENT_ID"
          
          NEXT_ID=$((CURRENT_ID + 1))
          echo "Next ID will be: $NEXT_ID"
          
          # Save the next ID for future use
          echo "$NEXT_ID" > "$ID_FILE"
          
          # Format the ID with leading zeros
          FORMATTED_ID=$(printf "%03d" $CURRENT_ID)
          echo "Formatted ID for this file: $FORMATTED_ID"
          
          # File to process
          FILE="$1"
          if [ ! -f "$FILE" ]; then
            echo "Error: File not found: $FILE"
            exit 1
          fi
          
          # Get base name and directory
          DIR=$(dirname "$FILE")
          BASE=$(basename "$FILE" .drawio)
          
          # Skip if it already has an ID
          if [[ "$BASE" =~ \(ID\ [0-9]+\)$ ]]; then
            echo "File already has an ID: $FILE"
            exit 0
          fi
          
          # New name with ID added
          NEW_NAME="${BASE} (ID ${FORMATTED_ID}).drawio"
          NEW_PATH="${DIR}/${NEW_NAME}"
          
          # Do the rename for drawio file
          echo "Renaming drawio file:"
          echo "  From: $FILE"
          echo "  To:   $NEW_PATH"
          mv "$FILE" "$NEW_PATH"
          
          # Also rename SVG file if it exists
          SVG_PATH="svg_files/${BASE}.svg"
          if [ -f "$SVG_PATH" ]; then
            NEW_SVG_NAME="${BASE} (ID ${FORMATTED_ID}).svg"
            NEW_SVG_PATH="svg_files/${NEW_SVG_NAME}"
            echo "Renaming SVG file:"
            echo "  From: $SVG_PATH"
            echo "  To:   $NEW_SVG_PATH"
            mv "$SVG_PATH" "$NEW_SVG_PATH"
          fi
          
          # Also rename HTML file if it exists
          HTML_PATH="html_files/${BASE}.html"
          if [ -f "$HTML_PATH" ]; then
            NEW_HTML_NAME="${BASE} (ID ${FORMATTED_ID}).html"
            NEW_HTML_PATH="html_files/${NEW_HTML_NAME}"
            echo "Renaming HTML file:"
            echo "  From: $HTML_PATH"
            echo "  To:   $NEW_HTML_PATH"
            mv "$HTML_PATH" "$NEW_HTML_PATH"
          fi
          
          # Update changelog if it exists
          CHANGELOG="html_files/CHANGELOG.csv"
          if [ -f "$CHANGELOG" ]; then
            echo "Updating changelog..."
            DATE=$(date +"%d.%m.%Y")
            TIME=$(date +"%H:%M:%S")
            USER="GitHub Actions"
            echo "${DATE},${TIME},\"${USER}\",\"${BASE} (ID ${FORMATTED_ID})\",\"ID Added\",\"${BASE} â†’ ${BASE} (ID ${FORMATTED_ID})\",\"Added ID ${FORMATTED_ID}\",\"1.0\",\"auto\",\"${FORMATTED_ID}\"" >> "$CHANGELOG"
          fi
          
          # Success message
          if [ -f "$NEW_PATH" ]; then
            echo "Success! File renamed with ID: $FORMATTED_ID"
          else
            echo "Error: Failed to rename file"
            exit 1
          fi
          EOL
          chmod +x /tmp/ultra_simple_id.sh
          
          # Create converter script
          cat > /tmp/convert-drawio.sh << 'EOL'
          #!/bin/bash
          
          # A simple script to convert Draw.io files to SVG and HTML formats
          
          input_file="$1"
          if [ ! -f "$input_file" ]; then
            echo "Error: File not found: $input_file"
            exit 1
          fi
          
          # Extract base name
          base_name=$(basename "$input_file" .drawio)
          
          # Output paths
          output_svg="svg_files/${base_name}.svg"
          output_html="html_files/${base_name}.html"
          
          # Set up virtual display for headless operation
          export DISPLAY=:99
          
          # Convert to SVG
          echo "Converting to SVG: $input_file -> $output_svg"
          if ! drawio -x -f svg -o "$output_svg" "$input_file"; then
            echo "Failed with direct command, trying with xvfb-run..."
            if ! xvfb-run --auto-servernum --server-args="-screen 0 1280x1024x24" drawio -x -f svg -o "$output_svg" "$input_file"; then
              echo "Error: SVG conversion failed"
              # Create a fallback SVG
              echo '<svg xmlns="http://www.w3.org/2000/svg" width="640" height="480" viewBox="0 0 640 480">
                <rect width="100%" height="100%" fill="#ffffcc"/>
                <text x="10" y="20" font-family="Arial" font-size="16">Error: Failed to convert diagram</text>
                <text x="10" y="45" font-family="Arial" font-size="12">Please check the file and try again</text>
              </svg>' > "$output_svg"
            fi
          fi
          
          # Create HTML wrapper
          echo "Creating HTML wrapper: $output_html"
          echo '<!DOCTYPE html>
          <html lang="en">
          <head>
            <meta charset="UTF-8">
            <title>'"$base_name"'</title>
            <style>
              body { margin: 0; padding: 0; }
              svg { max-width: 100%; height: auto; display: block; }
            </style>
          </head>
          <body>' > "$output_html"
          cat "$output_svg" >> "$output_html"
          echo '</body>
          </html>' >> "$output_html"
          
          # Add simple changelog entry
          if [ -f "html_files/CHANGELOG.csv" ]; then
            # Skip if ID was already added (it would have added to changelog)
            if ! grep -q "\"$base_name\"" "html_files/CHANGELOG.csv"; then
              echo "Adding to changelog: $base_name"
              DATE=$(date +"%d.%m.%Y")
              TIME=$(date +"%H:%M:%S")
              USER="GitHub Actions"
              HASH=$(git log -1 --format="%h" HEAD 2>/dev/null || echo "manual")
              
              # Extract ID if present
              ID=""
              if [[ "$base_name" =~ \(ID\ ([0-9]+)\) ]]; then
                ID="${BASH_REMATCH[1]}"
              fi
              
              echo "$DATE,$TIME,\"$USER\",\"$base_name\",\"Converted\",\"$base_name\",\"Converted to SVG/HTML\",\"1.0\",\"$HASH\",\"$ID\"" >> "html_files/CHANGELOG.csv"
            fi
          fi
          
          echo "Conversion complete: $input_file"
          EOL
          chmod +x /tmp/convert-drawio.sh
          
          # Set up Xvfb
          Xvfb :99 -screen 0 1280x1024x24 -nolisten tcp -ac +extension RANDR +render -noreset &
          XVFB_PID=$!
          export DISPLAY=:99
          sleep 2
          
          # Process each file: first add ID, then convert
          if [[ "${{ steps.changes.outputs.all_files }}" == "true" ]]; then
            echo "Processing all Draw.io files..."
            find drawio_files -name "*.drawio" > /tmp/files_to_process.txt
          else
            echo "Processing changed Draw.io files..."
            cat /tmp/changed_files.txt > /tmp/files_to_process.txt
          fi
          
          # First, assign IDs to all files
          while IFS= read -r file || [ -n "$file" ]; do
            if [ -f "$file" ]; then
              echo "==================================="
              echo "Adding ID to: $file"
              /tmp/ultra_simple_id.sh "$file"
              echo "==================================="
            fi
          done < /tmp/files_to_process.txt
          
          # Then, convert all files (which now have IDs)
          find drawio_files -name "*.drawio" > /tmp/files_with_ids.txt
          while IFS= read -r file || [ -n "$file" ]; do
            if [ -f "$file" ]; then
              echo "==================================="
              echo "Converting: $file"
              /tmp/convert-drawio.sh "$file"
              echo "==================================="
            fi
          done < /tmp/files_with_ids.txt
          
          # Kill Xvfb when done
          kill $XVFB_PID
      
      # Step 6: Commit and push changes with proper fetch/pull strategy
      - name: Commit and push changes
        if: steps.changes.outputs.has_changes == 'true'
        run: |
          git config --local user.name "github-actions[bot]"
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          
          # Add all changes
          git add svg_files/ html_files/ drawio_files/
          
          # Only commit if there are changes
          if ! git diff --staged --quiet; then
            # Commit the changes locally
            git commit -m "Assigned IDs to diagrams and converted to SVG/HTML"
            
            # Get current branch name
            BRANCH_NAME=${GITHUB_REF#refs/heads/}
            
            # Fetch the latest from remote to ensure we're up to date
            echo "Fetching latest changes from remote..."
            git fetch origin $BRANCH_NAME
            
            # Try to rebase our changes on top of the remote branch
            echo "Rebasing local changes on top of remote changes..."
            if git rebase origin/$BRANCH_NAME; then
              echo "Rebase successful, pushing changes..."
              git push "https://x-access-token:${{ github.token }}@github.com/${{ github.repository }}.git" $BRANCH_NAME
              echo "Changes committed and pushed successfully"
            else
              echo "Rebase had conflicts. Using alternative merge strategy..."
              # Abort the rebase and try a different approach
              git rebase --abort
              
              # Pull with --no-rebase to create a merge commit instead
              git fetch origin $BRANCH_NAME
              
              # First stash our changes to preserve them
              git add svg_files/ html_files/ drawio_files/
              git stash
              
              # Checkout and pull the latest changes
              git checkout $BRANCH_NAME
              git pull origin $BRANCH_NAME
              
              # Apply our stashed changes
              git stash pop
              
              # Handle potential conflicts
              if git status | grep -q "Unmerged paths"; then
                echo "Merge conflicts detected, attempting to resolve automatically..."
                
                # Generate diagnostic information for debugging
                echo "--- Git Status ---"
                git status
                echo "--- List of unmerged files ---"
                git diff --name-only --diff-filter=U
                echo "--------------------"
                
                # Handle CHANGELOG.csv specially if it's conflicted
                if git status | grep -q "html_files/CHANGELOG.csv"; then
                  echo "Resolving CHANGELOG.csv conflict..."
                  
                  # More robust approach to handle CSV conflicts
                  # Get the original header 
                  HEADER=$(grep "^Date,Time" html_files/CHANGELOG.csv || echo "Date,Time,User,Diagram,Action,File,Commit Message,Version,Commit Hash,ID")
                  
                  # Save header as first line
                  echo "$HEADER" > html_files/CHANGELOG.csv.resolved
                  
                  # Extract all entries that are not conflict markers and not the header
                  cat html_files/CHANGELOG.csv | grep -v "^<<<<<<< " | grep -v "^=======$" | grep -v "^>>>>>>> " | grep -v "^Date,Time" | sort | uniq >> html_files/CHANGELOG.csv.resolved
                  
                  # Replace conflicted file with resolved version
                  mv html_files/CHANGELOG.csv.resolved html_files/CHANGELOG.csv
                  
                  # Mark as resolved
                  git add html_files/CHANGELOG.csv
                  echo "CHANGELOG.csv conflict resolved automatically"
                fi
                
                # Handle other conflicts
                UNMERGED_FILES=$(git diff --name-only --diff-filter=U | grep -v "html_files/CHANGELOG.csv" || echo "")
                if [ -n "$UNMERGED_FILES" ]; then
                  echo "Resolving conflicts in other files..."
                  echo "$UNMERGED_FILES" | while read -r file; do
                    echo "Resolving conflict in: $file"
                    # For files other than CHANGELOG.csv, we'll keep our changes
                    git checkout --ours "$file"
                    git add "$file"
                  done
                  echo "Other conflicts resolved"
                fi
              fi
              
              # Commit our changes
              git commit -m "Assigned IDs to diagrams and converted to SVG/HTML (merge commit)"
              
              # Push with retry mechanism
              MAX_RETRIES=3
              RETRY_COUNT=0
              PUSH_SUCCESS=false
              
              while [ $RETRY_COUNT -lt $MAX_RETRIES ] && [ "$PUSH_SUCCESS" != "true" ]; do
                RETRY_COUNT=$((RETRY_COUNT+1))
                echo "Pushing changes to remote (attempt $RETRY_COUNT/$MAX_RETRIES)..."
                
                if git push "https://x-access-token:${{ github.token }}@github.com/${{ github.repository }}.git" $BRANCH_NAME; then
                  echo "Changes committed and pushed successfully using merge strategy"
                  PUSH_SUCCESS=true
                else
                  if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
                    echo "Push failed, retrying in 5 seconds..."
                    sleep 5
                    # Pull again to make sure we're up to date
                    git pull origin $BRANCH_NAME --no-edit
                  else
                    echo "Failed to push changes after $MAX_RETRIES attempts"
                    exit 1
                  fi
                fi
              done
            fi
          else
            echo "No changes to commit"
          fi
