name: Convert Draw.io Files

on:
  push:
    paths:
      - '**/*.drawio'
      - 'drawio_files/**'
  workflow_dispatch: # Enable manual triggering

# Add concurrency control to prevent queued workflows and resolve XKEYBOARD issues
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}-${{ github.sha }}
  cancel-in-progress: false

# Add permissions needed for the workflow
permissions:
  contents: write

jobs:
  convert:
    runs-on: ubuntu-latest

    steps:
      # Step 1: Check out the repository with history to detect changes
      - name: Check out the repository
        uses: actions/checkout@v3
        with:
          fetch-depth: 0 # Fetch all history to properly identify changed files
          
      # Step 1.1: Diagnostic information
      - name: Workflow diagnostic information
        run: |
          echo "============================================"
          echo "WORKFLOW DIAGNOSTIC INFORMATION"
          echo "============================================"
          echo "Repository: ${{ github.repository }}"
          echo "Branch: ${{ github.ref_name }}"
          echo "Actor: ${{ github.actor }}"
          echo "Workflow: ${{ github.workflow }}"
          echo "Event: ${{ github.event_name }}"
          echo "Commit: ${{ github.sha }}"
          echo "============================================"
          echo "LISTING DRAWIO FILES:"
          find drawio_files -name "*.drawio" -type f 2>/dev/null | sort || echo "No .drawio files found"
          echo "============================================"
          echo "GIT STATUS:"
          git status
          echo "============================================"
          echo "RECENTLY MODIFIED FILES:"
          git diff --name-only HEAD~5 HEAD 2>/dev/null || echo "Cannot get recent changes"
          echo "============================================"

      # Step 2: Install dependencies
      - name: Install Draw.io and dependencies
        run: |
          sudo apt-get update
          # Use libasound2t64 instead of libasound2 for Ubuntu Noble (24.04)
          sudo apt-get install -y wget unzip xvfb libasound2t64 libgbm1 libnspr4 libnss3 libxss1
          wget https://github.com/jgraph/drawio-desktop/releases/download/v26.2.2/drawio-amd64-26.2.2.deb
          sudo apt-get -f install -y
          sudo dpkg -i drawio-amd64-26.2.2.deb || sudo apt-get -f install -y
          
      # Step 1.2: Ensure directories exist
      - name: Create required directories
        run: |
          mkdir -p drawio_files svg_files html_files
          echo "Created necessary directories"

      # Step 2.5: Add .drawio extension to files without extension
      - name: Add .drawio extension to files without extension
        run: |
          # Check if drawio_files directory exists
          if [ -d "drawio_files" ]; then
            echo "Checking for files without extension in drawio_files directory..."
            
            # First, make sure we have the latest changes from remote
            echo "Fetching latest changes from remote repository..."
            git fetch "https://${{ github.actor }}:${{ secrets.GITHUB_TOKEN }}@github.com/${{ github.repository }}.git"
            
            # Find files without extension in drawio_files directory
            # Use find command with null separator to handle filenames with spaces
            find drawio_files -type f -not -path "*/\.*" -print0 | while IFS= read -r -d $'\0' file; do
              # Check if filename contains a dot (which indicates an extension)
              filename=$(basename "$file")
              if [[ "$filename" != *.* ]]; then
                # Check if the file actually exists before trying to rename it
                if [ -f "$file" ]; then
                  echo "Adding .drawio extension to: $file"
                  
                  # Check if target file already exists (in case we've already renamed it)
                  if [ -f "${file}.drawio" ]; then
                    echo "Warning: ${file}.drawio already exists. Skipping rename."
                  else
                    # Check if file is a drawing
                    file_type=$(file -b "$file" | grep -i "xml" || echo "")
                    if [[ -n "$file_type" || $(head -c 100 "$file" | grep -q "mxfile") ]]; then
                      echo "File appears to be a draw.io diagram. Renaming..."
                      # Rename the file
                      mv "$file" "${file}.drawio"
                      
                      # Add and commit the renamed file
                      git add "${file}.drawio"
                      # Also remove the original file if git still tracks it
                      git rm --ignore-unmatch "$file" > /dev/null 2>&1
                      
                      git config --local user.name "github-actions[bot]"
                      git config --local user.email "github-actions[bot]@users.noreply.github.com"
                      git commit -m "Add .drawio extension to $filename"
                      
                      # Push changes using improved fetch/pull strategy
                      echo "Pushing changes to remote repository..."
                      
                      # Get current branch name
                      BRANCH_NAME=${GITHUB_REF#refs/heads/}
                      
                      # Fetch latest changes
                      git fetch origin $BRANCH_NAME
                      
                      # Try to rebase first
                      if git rebase origin/$BRANCH_NAME; then
                        git push "https://x-access-token:${{ github.token }}@github.com/${{ github.repository }}.git" HEAD:$BRANCH_NAME
                        echo "✅ Changes pushed with rebase strategy"
                      else
                        # If rebase fails, try merge strategy
                        git rebase --abort
                        git pull --no-rebase origin $BRANCH_NAME
                        git add "${file}.drawio"
                        git commit -m "Add .drawio extension to $filename (merge commit)"
                        git push "https://x-access-token:${{ github.token }}@github.com/${{ github.repository }}.git" HEAD:$BRANCH_NAME
                        echo "✅ Changes pushed with merge strategy"
                      fi
                    fi
                  fi
                else
                  echo "Warning: File $file no longer exists, skipping."
                fi
              fi
            done
          else
            echo "drawio_files directory not found, skipping extension check."
          fi          # Step 3: Create output directories
      - name: Create output folders
        run: |
          mkdir -p svg_files html_files
          
          # Initialize CSV changelog with headers if it doesn't exist - now with commit hash column
          if [ ! -f "html_files/CHANGELOG.csv" ]; then
            echo "Date,Time,User,Diagram,Action,File,Commit Message,Version,Commit Hash" > html_files/CHANGELOG.csv
          fi
          # No longer creating changelog in svg_files folder

      # Step 4: Convert .drawio files to SVG and wrap them in HTML
      - name: Convert Draw.io files
        run: |
          # Set up virtual display for headless operation
          mkdir -p /tmp/.X11-unix
          Xvfb :99 -screen 0 1280x1024x24 -nolisten tcp -ac +extension RANDR +render -noreset &
          XVFB_PID=$!
          export DISPLAY=:99
          sleep 2 # Give Xvfb time to start
          
          # Verify Xvfb is running
          if ! ps -p $XVFB_PID > /dev/null; then
            echo "⚠️ Xvfb failed to start, trying alternative configuration..."
            xvfb-run --auto-servernum --server-args="-screen 0 1280x1024x24" echo "Testing Xvfb" || echo "Warning: xvfb-run test failed but continuing"
          else
            echo "✅ Xvfb started successfully with PID $XVFB_PID"
          fi
          
          # Create a simple converter script
          cat > /tmp/convert-drawio.sh << 'EOL'
          #!/bin/bash
          input_file=$1
          output_file=$2
          echo "Converting: $input_file to $output_file"
          
          # Try direct command first
          if drawio -x -f svg -o "$output_file" "$input_file"; then
            exit 0
          fi
          
          # Try with xvfb-run as fallback
          xvfb-run --auto-servernum --server-args="-screen 0 1280x1024x24" drawio -x -f svg -o "$output_file" "$input_file"
          EOL
          chmod +x /tmp/convert-drawio.sh
          
          # Track processed files
          > /tmp/processed_files.txt
          > /tmp/failed_files.txt
          
          # Find all .drawio files that changed in this commit
          git diff --name-only HEAD^ HEAD 2>/dev/null | grep -E "\.drawio$" > /tmp/changed_files.txt || echo "" > /tmp/changed_files.txt
          if [ ! -s /tmp/changed_files.txt ]; then
            # If first commit or other issue, get all .drawio files
            git diff-tree --name-only --no-commit-id --root -r HEAD | grep -E "\.drawio$" > /tmp/changed_files.txt || echo "" > /tmp/changed_files.txt
          fi
          
          echo "Files to process:"
          cat /tmp/changed_files.txt
          
          # Process each changed file
          while IFS= read -r file || [ -n "$file" ]; do
            if [ -f "$file" ]; then
              echo "Processing: $file"
              
              # Create output directories
              mkdir -p svg_files html_files
              
              # Get base name
              base=$(basename "$file" .drawio)
              output_svg="svg_files/${base}.svg"
              output_html="html_files/${base}.html"
              
              # Convert to SVG
              echo "Converting to SVG..."
              if /tmp/convert-drawio.sh "$file" "$output_svg"; then
                echo "✅ Successfully converted to SVG: $output_svg"
                
                # Create HTML wrapper
                echo "Creating HTML wrapper..."
                echo '<!DOCTYPE html>
          <html lang="en">
          <head>
            <meta charset="UTF-8">
            <title>'"$base"'</title>
            <style>
              body { margin: 0; padding: 0; }
              svg { max-width: 100%; height: auto; display: block; }
            </style>
          </head>
          <body>' > "$output_html"
                cat "$output_svg" >> "$output_html"
                echo '</body>
          </html>' >> "$output_html"
                
                # Add simple changelog entry
                echo "$(date +"%d.%m.%Y"),$(date +"%H:%M:%S"),\"$base\",\"$file\",\"\",\"$(git log -1 --format="%s" HEAD)\",\"$(git log -1 --format="%h" HEAD)\"" >> html_files/CHANGELOG.csv
                
                echo "$file" >> /tmp/processed_files.txt
              else
                echo "❌ Failed to convert: $file"
                echo "$file" >> /tmp/failed_files.txt
                
                # Create a placeholder SVG for failed conversions
                echo '<svg xmlns="http://www.w3.org/2000/svg" width="640" height="480" viewBox="0 0 640 480">
                  <rect width="100%" height="100%" fill="#ffffcc"/>
                  <text x="10" y="20" font-family="Arial" font-size="16">Error: Failed to convert diagram</text>
                  <text x="10" y="45" font-family="Arial" font-size="12">Please check the file and try again</text>
                </svg>' > "$output_svg"
                
                # Create an error HTML wrapper
                echo '<!DOCTYPE html>
          <html lang="en">
          <head>
            <meta charset="UTF-8">
            <title>'"$base"' (Conversion Failed)</title>
            <style>
              body { margin: 0; padding: 0; }
              svg { max-width: 100%; height: auto; display: block; }
              .error { color: red; padding: 10px; }
            </style>
          </head>
          <body>
            <div class="error">Conversion failed - please check the original file</div>' > "$output_html"
                cat "$output_svg" >> "$output_html"
                echo '</body>
          </html>' >> "$output_html"
              fi
            else
              echo "⚠️ File not found: $file"
            fi
          done < /tmp/changed_files.txt
          
          echo "Process completed."
          echo "Successful conversions: $(wc -l < /tmp/processed_files.txt)"
          echo "Failed conversions: $(wc -l < /tmp/failed_files.txt)"

      # Step 5: Commit and push changes
      - name: Commit and push changes
        id: commit_changes
        run: |
          git config --local user.name "github-actions[bot]"
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          
          # Fetch latest changes before adding our changes
          echo "Fetching latest changes from remote repository..."
          git fetch origin
          
          # Add our changes
          git add svg_files html_files
          
          # Only commit if there are changes
          if git diff --staged --quiet; then
            echo "No changes to commit"
            echo "changes_made=false" >> $GITHUB_OUTPUT
          else
            git commit -m "Auto-converted draw.io files"
            
            # Get current branch name
            BRANCH_NAME=${GITHUB_REF#refs/heads/}
            
            # Try to rebase our changes on the remote branch
            echo "Rebasing local changes on top of remote changes..."
            if git pull --rebase origin $BRANCH_NAME; then
              echo "Rebase successful, pushing changes..."
            else
              echo "Rebase had conflicts, switching to merge strategy..."
              git rebase --abort
              
              # Pull with merge strategy
              git pull --no-rebase origin $BRANCH_NAME
              
              # Re-add our changes in case they were lost in the merge
              git add svg_files html_files
              git commit -m "Auto-converted draw.io files (merge commit)"
            fi              # Use GitHub token for authentication and push with retry logic
            echo "Pushing changes to remote repository..."
            MAX_RETRIES=3
            RETRY_COUNT=0
            PUSH_SUCCESS=false
            
            while [ $RETRY_COUNT -lt $MAX_RETRIES ] && [ "$PUSH_SUCCESS" = false ]; do
              if git push "https://x-access-token:${{ github.token }}@github.com/${{ github.repository }}.git" HEAD:$BRANCH_NAME; then
                echo "Successfully pushed changes to remote repository."
                PUSH_SUCCESS=true
              else
                RETRY_COUNT=$((RETRY_COUNT + 1))
                if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
                  echo "Push failed. Trying pull again before retry..."
                  git pull --no-rebase origin $BRANCH_NAME
                  echo "Retry in 5 seconds... (Attempt $RETRY_COUNT of $MAX_RETRIES)"
                  sleep 5
                fi
              fi
            done
            
            if [ "$PUSH_SUCCESS" = true ]; then
              echo "✅ Changes successfully pushed after $RETRY_COUNT retries"
            else
              echo "❌ Failed to push changes after $MAX_RETRIES attempts"
            fi
            echo "changes_made=true" >> $GITHUB_OUTPUT
          fi
          
      # Step 5.1: Handle potential merge conflicts
      - name: Handle potential merge conflicts
        if: steps.commit_changes.outputs.changes_made == 'true'
        run: |
          # Check if there are merge conflicts
          if git status | grep -q "You have unmerged paths"; then
            echo "Detected merge conflicts. Attempting to resolve..."
            
            # Focus on CHANGELOG.csv which is the most common conflict
            if git status | grep -q "CHANGELOG.csv"; then
              echo "Resolving CHANGELOG.csv conflict..."
              
              # Create a backup of the conflicted file
              cp html_files/CHANGELOG.csv html_files/CHANGELOG.csv.backup
              
              # Extract the header (first line)
              head -n 1 html_files/CHANGELOG.csv.backup > html_files/CHANGELOG.csv.header
              
              # Extract all content between conflict markers and combine
              grep -v "^<<<<<<< HEAD$" html_files/CHANGELOG.csv.backup | 
              grep -v "^=======$" | 
              grep -v "^>>>>>>> " | 
              grep -v "^$" > html_files/CHANGELOG.csv.content
              
              # Remove duplicate headers from the content
              grep -v "^Date,Time" html_files/CHANGELOG.csv.content > html_files/CHANGELOG.csv.clean
              
              # Combine header with unique entries
              cat html_files/CHANGELOG.csv.header > html_files/CHANGELOG.csv
              cat html_files/CHANGELOG.csv.clean | sort -u >> html_files/CHANGELOG.csv
              
              # Mark as resolved
              git add html_files/CHANGELOG.csv
              echo "CHANGELOG.csv conflict resolved automatically"
              
              # Clean up temp files
              rm -f html_files/CHANGELOG.csv.backup html_files/CHANGELOG.csv.header html_files/CHANGELOG.csv.content html_files/CHANGELOG.csv.clean
            else
              echo "Conflicts detected in files other than CHANGELOG.csv."
              echo "Please check the workflow logs and resolve conflicts manually."
              exit 1
            fi
            
            # Continue with the rebase
            if git rebase --continue; then
              echo "Rebase completed successfully after resolving conflicts."
            else
              echo "Could not continue rebase. Please check the repository."
              exit 1
            fi
          else
            echo "No merge conflicts detected."
          fi
          
      # Step 5.2: Push changes after handling conflicts
      - name: Push changes
        if: steps.commit_changes.outputs.changes_made == 'true'
        run: |
          # Get current branch name
          BRANCH_NAME=${GITHUB_REF#refs/heads/}
          
          # Fetch latest changes before pushing
          echo "Fetching latest changes from remote..."
          git fetch origin $BRANCH_NAME
          
          # Try to rebase our changes on top of latest remote
          echo "Rebasing changes before push..."
          if git rebase origin/$BRANCH_NAME; then
            echo "Rebase successful, attempting push..."
          else
            echo "Rebase conflicts detected, switching to merge strategy..."
            git rebase --abort
            git pull --no-rebase origin $BRANCH_NAME
            # Re-add any changes that might have been lost in the merge
            git add svg_files/ html_files/ drawio_files/
            git commit -m "Auto-regenerate SVG/HTML diagrams (merge commit)"
          fi
          
          # Try to push changes, with multiple retries for transient issues
          MAX_RETRIES=3
          RETRY_COUNT=0
          PUSH_SUCCESS=false
          
          while [ $RETRY_COUNT -lt $MAX_RETRIES ] && [ "$PUSH_SUCCESS" = false ]; do
            if git push "https://x-access-token:${{ github.token }}@github.com/${{ github.repository }}.git" $BRANCH_NAME; then
              echo "Successfully pushed changes to remote repository."
              PUSH_SUCCESS=true
            else
              RETRY_COUNT=$((RETRY_COUNT + 1))
              if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
                echo "Push failed. Trying alternative strategy..."
                git pull --no-rebase origin $BRANCH_NAME
                echo "Retry in 5 seconds... (Attempt $RETRY_COUNT of $MAX_RETRIES)"
                sleep 5
                
                # Pull latest changes again before retrying
                echo "Pulling latest changes before retry..."
                git pull --rebase origin main || true
              else
                echo "Failed to push after $MAX_RETRIES attempts."
                echo "::warning::Failed to push changes automatically. Please check repository."
              fi
            fi
          done

      # Step 6: Upload changelog to SharePoint
      - name: Upload changelog to SharePoint
        if: steps.commit_changes.outputs.changes_made == 'true'
        uses: actions/github-script@v6
        with:
          script: |
            const fs = require('fs');
            const path = require('path');
            
            try {
              const https = require('https');
              console.log('Preparing to upload changelog to SharePoint...');
              
              // Read and format the changelog file for SharePoint
              const changelogPath = path.join(process.env.GITHUB_WORKSPACE, 'html_files', 'CHANGELOG.csv');
              console.log(`Reading changelog from: ${changelogPath}`);
              const rawContent = fs.readFileSync(changelogPath, 'utf8');
              
              // Format the changelog with proper headers and content
              // First, parse the existing CSV
              const lines = rawContent.split('\n').filter(line => line.trim());
              const header = lines[0]; // Get header row
              const dataRows = lines.slice(1); // Get data rows
              
              // Create a properly formatted CSV with all the needed columns in the requested order
              // Date, Time, Diagram, Action, File, Commit Message, Version, Commit Hash
              let fileContent = 'Date,Time,Diagram,Action,File,Commit Message,Version,Commit Hash\n';
              
              // Add the data rows with today's upload date
              const today = new Date().toLocaleDateString('en-GB', {
                day: '2-digit',
                month: '2-digit',
                year: 'numeric'
              }); // Format as DD.MM.YYYY
              
              // Process each row to handle the changed column ordering
              dataRows.forEach(row => {
                if (row.trim()) {
                  // Using a more robust CSV parsing approach
                  try {
                    // First, parse the CSV properly using a regex that handles quoted fields with commas
                    const parseCSV = (text) => {
                      const result = [];
                      const regex = /("[^"]*"|[^,"\r\n]+)(?=,|\r\n|$)|^(?=,|$)|,(?=,|$)/g;
                      let m;
                      
                      while ((m = regex.exec(text)) !== null) {
                        // Remove quotes if the field is quoted
                        let field = m[1] || '';
                        if (field.startsWith('"') && field.endsWith('"')) {
                          field = field.substring(1, field.length - 1);
                        }
                        result.push(field);
                      }
                      
                      return result;
                    };
                    
                    const extractedCols = parseCSV(row);
                    
                    // Ensure we have enough columns and handle missing values
                    while (extractedCols.length < 9) {
                      extractedCols.push('');
                    }
                    
                    // For reference, original columns are:
                    // [0]Date, [1]Time, [2]User, [3]Diagram, [4]Action, [5]File, [6]Commit Message, [7]Version, [8]Commit Hash
                    
                    // Keeping same format, just removing the SharePoint Upload Date:
                    // [0]Date, [1]Time, [2]Diagram, [3]Action, [4]File, [5]Commit Message, [6]Version, [7]Commit Hash
                    
                    // Create a properly formatted CSV row with quotes around each field
                    const formattedRow = [
                      extractedCols[0],                      // Date
                      extractedCols[1],                      // Time
                      `"${(extractedCols[3] || '').replace(/"/g, '""')}"`,  // Diagram
                      `"${(extractedCols[4] || '').replace(/"/g, '""')}"`,  // Action
                      `"${(extractedCols[5] || '').replace(/"/g, '""')}"`,  // File
                      `"${(extractedCols[6] || '').replace(/"/g, '""')}"`,  // Commit Message
                      extractedCols[7] || '',                // Version
                      extractedCols[8] || ''                 // Commit Hash
                    ].join(',');
                    
                    fileContent += formattedRow + '\n';
                  } catch (error) {
                    console.error(`Error processing CSV row: ${row}`, error);
                    // Skip this row if there's an error
                  }
                }
              });
              
              console.log(`Formatted changelog with ${dataRows.length} entries`);
              
              // Function to make HTTP requests with promises
              const httpRequest = (options, postData) => {
                return new Promise((resolve, reject) => {
                  const req = https.request(options, (res) => {
                    let data = '';
                    res.on('data', (chunk) => { data += chunk; });
                    res.on('end', () => {
                      if (res.statusCode >= 200 && res.statusCode < 300) {
                        try {
                          resolve(data.length > 0 ? JSON.parse(data) : {});
                        } catch (e) {
                          resolve(data); // Not JSON, return as string
                        }
                      } else {
                        reject(new Error(`HTTP Error: ${res.statusCode} ${data}`));
                      }
                    });
                  });
                  
                  req.on('error', reject);
                  
                  if (postData) {
                    req.write(postData);
                  }
                  req.end();
                });
              };
              
              // Step 1: Get access token with proper SharePoint permissions
              console.log('Getting access token...');
              const tokenBody = new URLSearchParams({
                client_id: process.env.CLIENT_ID,
                scope: 'https://graph.microsoft.com/.default',
                client_secret: process.env.CLIENT_SECRET,
                grant_type: 'client_credentials'
              }).toString();
              
              const tokenOptions = {
                method: 'POST',
                hostname: 'login.microsoftonline.com',
                path: `/${process.env.TENANT_ID}/oauth2/v2.0/token`,
                headers: {
                  'Content-Type': 'application/x-www-form-urlencoded',
                  'Content-Length': Buffer.byteLength(tokenBody)
                }
              };
              
              // Get token
              const tokenData = await httpRequest(tokenOptions, tokenBody);
              console.log('Access token obtained');
              
              // Step 2: Get drives if needed
              // Force drive ID detection regardless of configured value due to previous errors
              console.log('Attempting to detect SharePoint drives automatically...');
              
              // Verify the site ID from secrets
              try {
                console.log(`Verifying site ID from secret: ${process.env.SITE_ID}`);
                
                const siteOptions = {
                  method: 'GET',
                  hostname: 'graph.microsoft.com',
                  path: `/v1.0/sites/${process.env.SITE_ID}`,
                  headers: {
                    'Authorization': `Bearer ${tokenData.access_token}`,
                    'Accept': 'application/json'
                  }
                };
                
                const siteData = await httpRequest(siteOptions);
                console.log(`Site found: ${siteData.displayName || siteData.name}`);
              } catch (siteError) {
                console.error('Error verifying site:', siteError.message);
                console.log('Trying alternative site path format...');
                // If the site ID doesn't work, try a different format
                const originalSiteId = process.env.SITE_ID;
                try {
                  // Try sites/SiteName format
                  if (!originalSiteId.startsWith('sites/')) {
                    process.env.SITE_ID = `sites/${originalSiteId.split('/').pop()}`;
                  } else {
                    // Or try domain,sites,SiteName format
                    process.env.SITE_ID = `frostaag.sharepoint.com,${originalSiteId.replace('/', ',')}`;
                  }
                  console.log(`Using alternative site ID format: ${process.env.SITE_ID}`);
                } catch (formatError) {
                  console.error('Error reformatting site ID:', formatError);
                  // Keep the original if parsing fails
                }
              }
              
              // Now get the list of drives
              const drivesOptions = {
                method: 'GET',
                hostname: 'graph.microsoft.com',
                path: `/v1.0/sites/${process.env.SITE_ID}/drives`,
                headers: {
                  'Authorization': `Bearer ${tokenData.access_token}`,
                  'Accept': 'application/json'
                }
              };
              
              console.log(`Requesting drives list from: ${drivesOptions.path}`);
              const drivesData = await httpRequest(drivesOptions);
              
              if (!drivesData.value || drivesData.value.length === 0) {
                throw new Error(`No drives found for site: ${process.env.SITE_ID}`);
              }
              
              console.log('Available drives:');
              drivesData.value.forEach(d => console.log(`- ${d.name}: ${d.id}`));
              
              // Try to find the Documents drive - prioritize "Shared Documents" 
              console.log('Looking for document library named "Shared Documents"');
              const documentsDrive = drivesData.value.find(d => 
                d.name === 'Shared Documents' || 
                d.name === 'Documents' || 
                d.name.includes('Document')
              );
              
              let driveId;
              if (documentsDrive) {
                driveId = documentsDrive.id;
                console.log(`Selected document library: ${documentsDrive.name} (${driveId})`);
              } else {
                // Fall back to first drive
                driveId = drivesData.value[0].id;
                console.log(`No document library found, using first available drive: ${drivesData.value[0].name} (${driveId})`);
              }
              
              // Step 3: Upload the file - use consistent filename instead of date-stamped
              const fileName = 'Diagrams_Changelog.csv';  // Fixed filename that will be overwritten each time
              const folderPath = 'Diagrams';  // Target folder in SharePoint DatasphereFileStorage site
              console.log(`Uploading changelog as ${fileName} to folder "${folderPath}" in drive ${driveId}...`);
              
              // Create the folder if it doesn't exist
              try {
                const folderCheckOptions = {
                  method: 'GET',
                  hostname: 'graph.microsoft.com',
                  path: `/v1.0/sites/${process.env.SITE_ID}/drives/${driveId}/root:/${folderPath}`,
                  headers: {
                    'Authorization': `Bearer ${tokenData.access_token}`,
                    'Accept': 'application/json'
                  }
                };
                
                // Check if folder exists
                try {
                  await httpRequest(folderCheckOptions);
                  console.log(`Folder "${folderPath}" already exists`);
                } catch (folderError) {
                  if (folderError.message.includes('404')) {
                    // Folder doesn't exist, create it
                    console.log(`Creating folder "${folderPath}"...`);
                    const createFolderOptions = {
                      method: 'PATCH',
                      hostname: 'graph.microsoft.com',
                      path: `/v1.0/sites/${process.env.SITE_ID}/drives/${driveId}/root/children`,
                      headers: {
                        'Authorization': `Bearer ${tokenData.access_token}`,
                        'Content-Type': 'application/json',
                        'Accept': 'application/json'
                      }
                    };
                    
                    await httpRequest(createFolderOptions, JSON.stringify({
                      name: folderPath,
                      folder: {},
                      '@microsoft.graph.conflictBehavior': 'rename'
                    }));
                    console.log(`Folder "${folderPath}" created successfully`);
                  } else {
                    throw folderError;
                  }
                }
              } catch (folderCreateError) {
                console.error(`Error managing folder "${folderPath}":`, folderCreateError.message);
                console.log('Will attempt to upload to the folder anyway...');
              }
              
              // Upload file to the specified folder
              const uploadOptions = {
                method: 'PUT',
                hostname: 'graph.microsoft.com',
                path: `/v1.0/sites/${process.env.SITE_ID}/drives/${driveId}/root:/${folderPath}/${fileName}:/content`,
                headers: {
                  'Authorization': `Bearer ${tokenData.access_token}`,
                  'Content-Type': 'text/csv',
                  'Content-Length': Buffer.byteLength(fileContent)
                }
              };
              
              const uploadData = await httpRequest(uploadOptions, fileContent);
              console.log('Successfully uploaded changelog to SharePoint');
              console.log(`File URL: ${uploadData.webUrl}`);
              
            } catch (error) {
              console.error('Error uploading to SharePoint:', error.message);
              // Don't fail the workflow if SharePoint upload fails
            }
        env:
          TENANT_ID: ${{ secrets.TENANT_ID }}
          CLIENT_ID: ${{ secrets.CLIENT_ID }}
          CLIENT_SECRET: ${{ secrets.CLIENT_SECRET }}
          SITE_ID: ${{ secrets.SITE_ID }}
          DRIVE_ID: ${{ secrets.DRIVE_ID || 'auto' }}
  
  # Notifications for both success and failure
  teams-notification:
    needs: convert
    runs-on: ubuntu-latest
    if: ${{ always() }}  # Run this job whether the main job succeeds or fails
    
    steps:
      # This step runs only on success
      - name: Send Teams success notification
        if: ${{ needs.convert.result == 'success' }}
        run: |
          # Create JSON payload for Teams webhook
          PAYLOAD=$(cat << EOF
          {
            "@type": "MessageCard",
            "@context": "https://schema.org/extensions",
            "themeColor": "00FF00",
            "summary": "Draw.io Conversion Workflow Succeeded",
            "sections": [
              {
                "activityTitle": "✅ Draw.io Conversion Workflow Completed",
                "activitySubtitle": "Diagrams were successfully processed",
                "facts": [
                  {
                    "name": "Repository",
                    "value": "${{ github.repository }}"
                  },
                  {
                    "name": "Workflow",
                    "value": "${{ github.workflow }}"
                  },
                  {
                    "name": "Commit",
                    "value": "${{ github.sha }}"
                  },
                  {
                    "name": "Triggered by",
                    "value": "${{ github.actor }}"
                  }
                ],
                "markdown": true
              }
            ],
            "potentialAction": [
              {
                "@type": "OpenUri",
                "name": "View Workflow Run",
                "targets": [
                  {
                    "os": "default",
                    "uri": "https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}"
                  }
                ]
              }
            ]
          }
          EOF
          )
          
          # Send the payload to Teams webhook
          curl -H "Content-Type: application/json" -d "$PAYLOAD" "${{ secrets.TEAMS_WEBHOOK }}"

      # This step runs only on failure
      - name: Send Teams failure notification
        if: ${{ needs.convert.result == 'failure' }}
        run: |
          # Create JSON payload for Teams webhook
          PAYLOAD=$(cat << EOF
          {
            "@type": "MessageCard",
            "@context": "https://schema.org/extensions",
            "themeColor": "FF0000",
            "summary": "Draw.io Conversion Workflow Failed",
            "sections": [
              {
                "activityTitle": "❌ Draw.io Conversion Workflow Failed",
                "activitySubtitle": "GitHub Actions workflow run failed",
                "facts": [
                  {
                    "name": "Repository",
                    "value": "${{ github.repository }}"
                  },
                  {
                    "name": "Workflow",
                    "value": "${{ github.workflow }}"
                  },
                  {
                    "name": "Commit",
                    "value": "${{ github.sha }}"
                  },
                  {
                    "name": "Triggered by",
                    "value": "$TRIGGERER_NAME"
                  },
                  {
                    "name": "Run ID",
                    "value": "${{ github.run_id }}"
                  }
                ],
                "markdown": true
              }
            ],
            "potentialAction": [
              {
                "@type": "OpenUri",
                "name": "View Workflow Run",
                "targets": [
                  {
                    "os": "default",
                    "uri": "https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}"
                  }
                ]
              }
            ]
          }
          EOF
          )
          
          # Send the payload to Teams webhook
          curl -H "Content-Type: application/json" -d "$PAYLOAD" "${{ secrets.TEAMS_WEBHOOK }}"
      # Step 2: Check for file changes
      - name: Check for changed Draw.io files
        id: check_files
        run: |
          echo "Checking for changed .drawio files..."
          
          # Initialize output
          CHANGES_DETECTED=false
          
          # Method 1: Check for changes between HEAD and HEAD^
          echo "Trying method 1: git diff HEAD^ HEAD"
          if git diff --name-only HEAD^ HEAD 2>/dev/null | grep -q "\.drawio$"; then
            CHANGES_DETECTED=true
            echo "Changes detected using method 1"
          fi
          
          # If method 1 failed, try method 2 (useful for initial commits)
          if [ "$CHANGES_DETECTED" = false ]; then
            echo "Trying method 2: git diff-tree (for initial commits)"
            if git diff-tree --no-commit-id --name-only -r HEAD 2>/dev/null | grep -q "\.drawio$"; then
              CHANGES_DETECTED=true
              echo "Changes detected using method 2"
            fi
          fi
          
          # If still no changes detected, try method 3 (list all .drawio files on a new repo)
          if [ "$CHANGES_DETECTED" = false ]; then
            echo "Trying method 3: check for existence of any .drawio files"
            if find . -name "*.drawio" -type f 2>/dev/null | grep -q "\.drawio$"; then
              CHANGES_DETECTED=true
              echo "Changes detected using method 3 (found .drawio files)"
            fi
          fi
          
          # Set the output
          if [ "$CHANGES_DETECTED" = true ]; then
            echo "files_changed=true" >> $GITHUB_OUTPUT
            echo ".drawio files were changed or found in this commit"
            
            # List the files that were changed/found for better debugging
            echo "Changed or found .drawio files:"
            git diff --name-only HEAD^ HEAD 2>/dev/null | grep "\.drawio$" || \
            git diff-tree --no-commit-id --name-only -r HEAD 2>/dev/null | grep "\.drawio$" || \
            find . -name "*.drawio" -type f | sort
          else
            echo "files_changed=false" >> $GITHUB_OUTPUT
            echo "No .drawio files were changed in this commit"
          fi
      # Step 3: Analyze and process new diagrams for auto ID assignment
      - name: Auto-assign IDs to new diagrams
        id: auto_id
        if: ${{ steps.check_files.outputs.files_changed == 'true' }}
        run: |
          # Initialize outputs
          echo "id_assigned=false" >> $GITHUB_OUTPUT
          echo "renamed_files=" >> $GITHUB_OUTPUT
          
          # Create a list to store renamed files
          RENAMED_FILES=()
          ID_ASSIGNED=false
          
          # Get list of changed Draw.io files in this commit using multiple methods
          echo "Getting list of .drawio files to process..."
          
          # Method 1: Standard diff (most commits)
          CHANGED_FILES=$(git diff --name-only HEAD^ HEAD 2>/dev/null | grep "\.drawio$" || echo "")
          
          # Method 2: For initial commits
          if [ -z "$CHANGED_FILES" ]; then
            CHANGED_FILES=$(git diff-tree --no-commit-id --name-only -r HEAD 2>/dev/null | grep "\.drawio$" || echo "")
            echo "Using diff-tree method for initial commit, found: $CHANGED_FILES"
          fi
          
          # Method 3: For new repositories, check all .drawio files
          if [ -z "$CHANGED_FILES" ]; then
            CHANGED_FILES=$(find . -name "*.drawio" -type f | sed 's|^\./||' || echo "")
            echo "Using find method for new repository, found: $CHANGED_FILES"
          fi
          
          echo "Draw.io files to process: $CHANGED_FILES"
          
          # Debug output
          echo "Current directory: $(pwd)"
          echo "Listing all .drawio files for reference:"
          find . -name "*.drawio" -type f | sort
          
          # Process each changed file to see if it needs ID assignment
          for file in $CHANGED_FILES; do
            # Make sure the file exists (useful if we're parsing git output)
            if [ ! -f "$file" ]; then
              echo "File not found: $file, skipping..."
              continue
            fi
            
            # Extract just the filename without path and extension
            base_name=$(basename "$file" .drawio)
            
            # Extra debug information
            echo "--------------------------------------------"
            echo "AUTO-ID PROCESSING: $file"
            echo "Base name: $base_name"
            echo "File exists: $([ -f "$file" ] && echo "Yes" || echo "No")"
            echo "File size: $(wc -c < "$file") bytes"
            echo "--------------------------------------------"
            
            # Test each pattern (for debugging)
            echo "Testing naming patterns:"
            if [[ "$base_name" =~ ^[0-9]+\.[0-9]+\.[0-9]+\.\ .* ]]; then
              echo "✓ Pattern 1 (X.Y.Z. Name) matches: Complete ID with dot"
            else
              echo "✗ Pattern 1 (X.Y.Z. Name) does NOT match"
            fi
            
            if [[ "$base_name" =~ ^[0-9]+\.[0-9]+\.\ .* ]]; then
              echo "✓ Pattern 2 (X.Y. Name) matches: Partial ID with dot"
            else
              echo "✗ Pattern 2 (X.Y. Name) does NOT match"
            fi
            
            if [[ "$base_name" =~ ^[0-9]+\.[0-9]+\ .* ]]; then
              echo "✓ Pattern 3 (X.Y Name) matches: Partial ID without dot - NEEDS AUTO-ID"
            else
              echo "✗ Pattern 3 (X.Y Name) does NOT match"
            fi
            
            # Check file patterns in order using simplified approach
            
            # Extract first part (prefix) and rest (name)
            PREFIX_PART=${base_name%% *}
            NAME_PART=${base_name#* }
            
            # Debug
            echo "  Prefix Part: '$PREFIX_PART'"
            echo "  Name Part: '$NAME_PART'"
            
            # Patterns:
            # 1. X.Y.Z. Name - already has full ID with dot
            # 2. X.Y.Z Name - already has full ID without dot
            # 3. X.Y. Name - already has partial ID with dot
            # 4. X.Y Name - needs ID assignment (the pattern we're looking for)
            
            # Check if this is a file that needs ID assignment (X.Y Name format)
            # It should have exactly one dot, two numbers, and no dot after second number
            if [[ "$PREFIX_PART" == [0-9]*.[0-9]* && "$PREFIX_PART" != *. ]]; then
              # Count dots to make sure there's exactly one
              DOT_COUNT=$(echo "$PREFIX_PART" | tr -cd '.' | wc -c)
              if [ "$DOT_COUNT" -eq 1 ]; then
                echo "✅ Found file that needs auto-ID assignment: $file"
                
                # Simple extraction
                CATEGORY=${PREFIX_PART%%.*}
                DETAIL=${PREFIX_PART#*.}
                PREFIX="$CATEGORY.$DETAIL"
                NAME="$NAME_PART"
                
                # Debug extracted parts
                echo "Extracted parts:"
                echo "  Category: '$CATEGORY'"
                echo "  Detail: '$DETAIL'"
                echo "  Prefix: '$PREFIX'"
                echo "  Name: '$NAME'"
                
                # Find highest existing ID for this prefix
                HIGHEST_ID=0
                echo "Looking for existing diagrams with prefix $PREFIX..."
                
                # Safety check to avoid expanding to literal '*' if no files match
                shopt -s nullglob
                
                # Look for files matching the pattern X.Y.Z. format with different variations
                for existing in drawio_files/*.drawio; do
                  [ -f "$existing" ] || continue
                  
                  existing_base=$(basename "$existing" .drawio)
                  
                  # Pattern 1: X.Y.Z. Name format (with dot)
                  if [[ "$existing_base" =~ ^${PREFIX}\.([0-9]+)\.\ .* ]]; then
                    CURRENT_ID="${BASH_REMATCH[1]}"
                    echo "    ✓ Found ID: $CURRENT_ID (X.Y.Z. format)"
                    
                    if [[ "$CURRENT_ID" -gt "$HIGHEST_ID" ]]; then
                      HIGHEST_ID="$CURRENT_ID"
                      echo "    → New highest ID: $HIGHEST_ID"
                    fi
                    
                  # Pattern 2: X.Y.Z Name format (without dot)
                  elif [[ "$existing_base" =~ ^${PREFIX}\.([0-9]+)\ .* ]]; then
                    CURRENT_ID="${BASH_REMATCH[1]}"
                    echo "    ✓ Found ID: $CURRENT_ID (X.Y.Z format)"
                    
                    if [[ "$CURRENT_ID" -gt "$HIGHEST_ID" ]]; then
                      HIGHEST_ID="$CURRENT_ID"
                      echo "    → New highest ID: $HIGHEST_ID"
                    fi
                  fi
                done
                
                # Reset shell option
                shopt -u nullglob
                
                echo "Highest existing ID found: $HIGHEST_ID"
                
                # Handle case where no existing IDs were found - start with 1
                if [ "$HIGHEST_ID" -eq 0 ]; then
                  echo "No existing IDs found, starting with ID 1"
                fi
                
                # Calculate next ID
                NEXT_ID=$((HIGHEST_ID + 1))
                echo "Next ID: $NEXT_ID"
              
              echo "Matched pattern for file needing ID: $file"
              echo "  Category: $CATEGORY"
              echo "  Detail: $DETAIL"
              echo "  Prefix: $PREFIX"
              echo "  Name: $NAME"
              
              echo "Found file with partial ID: $file"
              echo "Prefix: $PREFIX, Name: $NAME"
              
              # Find highest existing ID for this prefix
              HIGHEST_ID=0
              echo "Looking for existing diagrams with prefix $PREFIX..."
              
              # Safety check to avoid expanding to literal '*' if no files match
              shopt -s nullglob
              
              # Look for files matching the pattern X.Y.Z. format with different variations
              for existing in drawio_files/*.drawio; do
                [ -f "$existing" ] || continue
                
                existing_base=$(basename "$existing" .drawio)
                echo "  Checking: $existing_base"
                
                # Pattern 1: X.Y.Z. Name format (with dot)
                if [[ "$existing_base" =~ ^${PREFIX}\.([0-9]+)\.\ .* ]]; then
                  CURRENT_ID="${BASH_REMATCH[1]}"
                  echo "    ✓ Found ID: $CURRENT_ID (X.Y.Z. format)"
                  
                  if [[ "$CURRENT_ID" -gt "$HIGHEST_ID" ]]; then
                    HIGHEST_ID="$CURRENT_ID"
                    echo "    → New highest ID: $HIGHEST_ID"
                  fi
                  
                # Pattern 2: X.Y.Z Name format (without dot)
                elif [[ "$existing_base" =~ ^${PREFIX}\.([0-9]+)\ .* ]]; then
                  CURRENT_ID="${BASH_REMATCH[1]}"
                  echo "    ✓ Found ID: $CURRENT_ID (X.Y.Z format)"
                  
                  if [[ "$CURRENT_ID" -gt "$HIGHEST_ID" ]]; then
                    HIGHEST_ID="$CURRENT_ID"
                    echo "    → New highest ID: $HIGHEST_ID"
                  fi
                fi
              done
              
              # Reset shell option
              shopt -u nullglob
              
              echo "Highest existing ID found: $HIGHEST_ID"
              
              # Handle case where no existing IDs were found - start with 1
              if [ "$HIGHEST_ID" -eq 0 ]; then
                echo "No existing IDs found, starting with ID 1"
              fi
              
              # Calculate next ID
              NEXT_ID=$((HIGHEST_ID + 1))
              
              # Generate new filename with proper formatting
              NEW_NAME="${PREFIX}.${NEXT_ID}. ${NAME}"
              NEW_PATH="drawio_files/${NEW_NAME}.drawio"
              
              echo "Renaming: $file -> $NEW_PATH (next ID: $NEXT_ID)"
              
              # Debug - verify files before moving
              echo "Source file exists: $([ -f "$file" ] && echo "YES" || echo "NO")"
              echo "Target directory exists: $([ -d "$(dirname "$NEW_PATH")" ] && echo "YES" || echo "NO")"
              
              # First make sure the target directory exists
              mkdir -p $(dirname "$NEW_PATH")
              
              # Check if target file already exists (shouldn't happen but just in case)
              if [ -f "$NEW_PATH" ]; then
                echo "WARNING: Target file already exists: $NEW_PATH"
                echo "Will use a unique name to avoid conflicts"
                NEW_PATH="drawio_files/${PREFIX}.${NEXT_ID}.${RANDOM}. ${NAME}.drawio"
                echo "New target path: $NEW_PATH"
              fi
              
              # Try to do the actual rename now with multiple fallbacks
              echo "Attempting to rename file..."
              if git mv -f "$file" "$NEW_PATH" 2>/dev/null; then
                echo "✅ Successfully renamed file with git mv"
              else
                echo "git mv failed, trying regular mv"
                if cp "$file" "$NEW_PATH"; then
                  echo "✅ Successfully copied file, now handling git"
                  # Now update git
                  git add "$NEW_PATH"
                  git rm -f "$file" 2>/dev/null || true
                else
                  echo "❌ ERROR: Failed to rename file: $file"
                  continue
                fi
              fi
              
              # Verify the rename was successful
              if [ -f "$NEW_PATH" ]; then
                echo "✅ File rename confirmed successful: $NEW_PATH exists"
              else
                echo "❌ ERROR: Renamed file doesn't exist: $NEW_PATH"
                continue
              fi
              
              RENAMED_FILES+=("$NEW_PATH")
              ID_ASSIGNED=true
              
              echo "Successfully renamed diagram with next available ID: $NEXT_ID"
            fi
          done
          
          # Set outputs
          if [ "$ID_ASSIGNED" = true ]; then
            echo "id_assigned=true" >> $GITHUB_OUTPUT
            echo "renamed_files=${RENAMED_FILES[*]}" >> $GITHUB_OUTPUT
          fi
      
      # Step 3.1: Commit the renamed diagrams if any
      - name: Commit renamed diagrams
        id: commit_renamed
        if: ${{ steps.auto_id.outputs.id_assigned == 'true' }}
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"
          
          # Create timestamp for unique commit message
          TIMESTAMP=$(date +"%Y%m%d%H%M%S")
          
          echo "Preparing to commit renamed files..."
          
          # First, let's check the state of the repository
          echo "Current git status:"
          git status
          
          # Add all potential renamed files
          git add drawio_files/*.drawio
          
          # Check if there are really changes to commit
          if git diff --staged --quiet; then
            echo "No changes to commit after renaming."
            echo "commit_done=false" >> $GITHUB_OUTPUT
          else
            echo "Changes detected, committing..."
            
            # Create a detailed commit message with the files that were renamed
            COMMIT_MSG="Auto-assigned IDs to new diagrams [${TIMESTAMP}]"
            RENAMED_FILES=$(git diff --staged --name-only | grep '\.drawio$' | tr '\n' ' ')
            
            if [ -n "$RENAMED_FILES" ]; then
              COMMIT_MSG="${COMMIT_MSG} - Renamed: ${RENAMED_FILES}"
            fi
            
            # Commit the changes
            git commit -m "$COMMIT_MSG"
            echo "commit_done=true" >> $GITHUB_OUTPUT
            
            # Push the changes with proper fetch/pull strategy
            echo "Pushing changes to remote repository..."
            
            # Get current branch name
            BRANCH_NAME=${GITHUB_REF#refs/heads/}
            
            # Fetch the latest from remote to ensure we're up to date
            echo "Fetching latest changes from remote..."
            git fetch origin $BRANCH_NAME
            
            # Try to rebase our changes on top of the remote branch
            echo "Rebasing local changes on top of remote changes..."
            if git rebase origin/$BRANCH_NAME; then
              echo "Rebase successful, pushing changes..."
              git push "https://x-access-token:${{ github.token }}@github.com/${{ github.repository }}.git" $BRANCH_NAME
              echo "✅ Successfully committed and pushed renamed files"
            else
              echo "⚠️ Rebase had conflicts. Using alternative merge strategy..."
              # Abort the rebase and try a different approach
              git rebase --abort
              
              # Pull with --no-rebase to create a merge commit instead
              git fetch origin $BRANCH_NAME
              
              # First stash our changes to preserve them
              git add drawio_files/*.drawio
              git stash
              
              # Checkout and pull the latest changes
              git checkout $BRANCH_NAME
              git pull origin $BRANCH_NAME
              
              # Apply our stashed changes
              git stash pop
              
              # Handle potential conflicts, especially in CHANGELOG.csv
              if git status | grep -q "Unmerged paths"; then
                echo "Merge conflicts detected, attempting to resolve automatically..."
                
                # Check if CHANGELOG.csv is one of the conflicted files
                if git status | grep -q "html_files/CHANGELOG.csv"; then
                  echo "Resolving CHANGELOG.csv conflict..."
                  
                  # Create a backup of the conflicted file
                  cp html_files/CHANGELOG.csv html_files/CHANGELOG.csv.backup
                  
                  # Extract the header (first line)
                  head -n 1 html_files/CHANGELOG.csv.backup > html_files/CHANGELOG.csv.header
                  
                  # Extract all content between conflict markers and combine
                  grep -v "^<<<<<<< HEAD$" html_files/CHANGELOG.csv.backup | 
                  grep -v "^=======$" | 
                  grep -v "^>>>>>>> " | 
                  grep -v "^$" > html_files/CHANGELOG.csv.content
                  
                  # Remove duplicate headers from the content
                  grep -v "^Date,Time" html_files/CHANGELOG.csv.content > html_files/CHANGELOG.csv.clean
                  
                  # Combine header with unique entries
                  cat html_files/CHANGELOG.csv.header > html_files/CHANGELOG.csv
                  cat html_files/CHANGELOG.csv.clean | sort -u >> html_files/CHANGELOG.csv
                  
                  # Mark as resolved
                  git add html_files/CHANGELOG.csv
                  echo "CHANGELOG.csv conflict resolved automatically"
                  
                  # Clean up temp files
                  rm -f html_files/CHANGELOG.csv.backup html_files/CHANGELOG.csv.header html_files/CHANGELOG.csv.content html_files/CHANGELOG.csv.clean
                else
                  echo "Warning: Unhandled merge conflicts in files other than CHANGELOG.csv"
                  # Just take ours version for now to avoid workflow failure
                  git checkout --ours .
                  git add .
                fi
              fi
              
              # Create a commit with our changes
              git commit -m "$COMMIT_MSG (merge commit)"
              git push "https://x-access-token:${{ github.token }}@github.com/${{ github.repository }}.git" $BRANCH_NAME
              echo "✅ Successfully committed and pushed renamed files using merge strategy"
            fi
          fi
      # Step 4: Detect and regenerate missing HTML/SVG files
      - name: Check for missing generated files
        id: check_missing
        run: |
          # Initialize variables to track if missing files were found
          MISSING_HTML_FILES=false
          MISSING_SVG_FILES=false
          MISSING_FILES_LIST=""
          
          # Create these directories if they don't exist
          mkdir -p svg_files html_files
          
          echo "Checking for Draw.io files without corresponding HTML or SVG files..."
          for drawio_file in drawio_files/*.drawio; do
            # Skip if no files match
            [ -e "$drawio_file" ] || continue
            
            # Get the base name without extension
            base_name=$(basename "$drawio_file" .drawio)
            
            # Check if HTML file exists
            html_file="html_files/${base_name}.html"
            if [ ! -f "$html_file" ]; then
              echo "Missing HTML file for: $drawio_file"
              MISSING_HTML_FILES=true
              MISSING_FILES_LIST="${MISSING_FILES_LIST}${base_name} (HTML), "
            fi
            
            # Check if SVG file exists
            svg_file="svg_files/${base_name}.svg"
            if [ ! -f "$svg_file" ]; then
              echo "Missing SVG file for: $drawio_file"
              MISSING_SVG_FILES=true
              MISSING_FILES_LIST="${MISSING_FILES_LIST}${base_name} (SVG), "
            fi
            
            # If either file is missing, add the drawio file to the queue for processing
            if [ ! -f "$html_file" ] || [ ! -f "$svg_file" ]; then
              echo "$drawio_file" >> /tmp/files_to_process.txt
            fi
          done
          
          # Trim trailing comma and space
          MISSING_FILES_LIST="${MISSING_FILES_LIST%, }"
          
          # Set outputs for conditional steps
          if [ "$MISSING_HTML_FILES" = true ] || [ "$MISSING_SVG_FILES" = true ]; then
            echo "missing_files=true" >> $GITHUB_OUTPUT
            echo "missing_files_list=$MISSING_FILES_LIST" >> $GITHUB_OUTPUT
          else
            echo "missing_files=false" >> $GITHUB_OUTPUT
          fi
      
      # Step 4.1: Process missing files if any
      - name: Regenerate missing files
        if: ${{ steps.check_missing.outputs.missing_files == 'true' }}
        run: |
          echo "Regenerating missing HTML/SVG files..."
          
          # Create a function for processing the diagram files
          process_missing_diagram() {
            local file_to_process="$1"
            echo "===== Processing missing files for: $file_to_process ====="
            
            # Get the base filename without extension, preserving spaces
            local base_name=$(basename "$file_to_process" .drawio)
            echo "Base name: $base_name"
            
            # Output files
            local output_svg="svg_files/${base_name}.svg"
            local output_html="html_files/${base_name}.html"
            
            # Only regenerate SVG if it's missing
            if [ ! -f "$output_svg" ]; then
              echo "Regenerating SVG file..."
              # Convert to SVG using the standard approach
              xvfb-run -a drawio -x -f svg -o "$output_svg" "$file_to_process"
              
              # Check if conversion succeeded
              if [ ! -f "$output_svg" ]; then
                echo "Warning: SVG generation failed for $file_to_process"
                # Create a placeholder SVG
                echo '<svg xmlns="http://www.w3.org/2000/svg" width="640" height="480" viewBox="0 0 640 480"><rect width="100%" height="100%" fill="#fff1f1"/><text x="50%" y="50%" font-family="Arial" font-size="16" text-anchor="middle">SVG Regeneration Failed</text><text x="50%" y="50%" font-family="Arial" font-size="12" text-anchor="middle" dy="20">Please update this diagram file</text></svg>' > "$output_svg"
              fi
            fi
            
            # Only regenerate HTML if it's missing
            if [ ! -f "$output_html" ]; then
              echo "Regenerating HTML file..."
              echo '<!DOCTYPE html>' > "$output_html"
              echo '<html lang="en">' >> "$output_html"
              echo '<head>' >> "$output_html"
              echo '  <meta charset="UTF-8">' >> "$output_html"
              echo "  <title>${base_name}</title>" >> "$output_html"
              echo '  <style>' >> "$output_html"
              echo '    body { margin: 0; padding: 0; }' >> "$output_html"
              echo '    svg { max-width: 100%; height: auto; display: block; }' >> "$output_html"
              echo '  </style>' >> "$output_html"
              echo '</head>' >> "$output_html"
              echo '<body>' >> "$output_html"
              
              # If SVG exists, include it
              if [ -f "$output_svg" ]; then
                cat "$output_svg" >> "$output_html"
              else
                echo "<p>Error: SVG file not found for ${base_name}</p>" >> "$output_html"
              fi
              
              echo '</body>' >> "$output_html"
              echo '</html>' >> "$output_html"
            fi
            
            echo "Completed regeneration of missing files for $file_to_process"
          }
          
          # Process each file that has missing HTML or SVG
          if [ -f "/tmp/files_to_process.txt" ]; then
            while IFS= read -r file || [ -n "$file" ]; do
              process_missing_diagram "$file"
            done < "/tmp/files_to_process.txt"
          fi
          
          echo "Finished regenerating all missing files"
